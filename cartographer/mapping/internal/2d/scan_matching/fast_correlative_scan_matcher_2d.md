产生“预计算栅格”的函数，几乎是最长最难的一个函数了，此处贴出：
```cpp
Q.add(p[0,y])    
for x = [1, w-1]:
	I[x-1,y] = Q.max
    if x < xcells: Q.add(p[x, y])

for x = [w, xcells-1]:
	I[x-1, y] = Q.max
    Q.rm(p[x-w, y])
    Q.add(p[x, y])
 
for x = [max{xcells, w}, xcells + w - 1]:
	I[x-1, y] = Q.max
    Q.rm(p[x-w], y)
```

一开始的时候，窗口装入第一个数据；

x就是下一个待处理的窗格：在正式处理之前，先把Q中现有的最大值给x前面的格子位置，I中的元素；这样的话，I(x,y)的元素就是"以(x,y)作为结尾的滑动窗口的最大值"，此时滑动窗口的开头坐标是什么呢？就是(x-w+1,y)。

后续的计算过程如出一辙：遍历列。

最后得到的C，元素C(x,y)就是原栅格M中，以(x,y)作为结尾的w*w扫描窗口的最大值。或者说，以(x-w+1, y-w+1)作为开头的滑动窗口的最大值。

所以，如果我需要查询以kx，ky开头的w*w区域最大值，当然就是查询P(kx+w-1, ky+w-1)的值



可以有三个阶段：只装入不弹出；一边装入一边弹出；只弹出不装入

至于w大于xcells的情况，自行推演即可。容易得很。



